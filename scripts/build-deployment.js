#!/usr/bin/env node

/**
 * GlowHost Contact Form System - Deployment Build Script
 * Validates and optimizes build output for shared hosting deployment
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const BUILD_DIR = 'out';
const DEPLOYMENT_DIR = 'deployment-package';

// Configuration
const config = {
  requiredFiles: [
    'index.html',
    '_next'
  ],
  requiredDirs: [
    'api',
    'config'
  ],
  excludeFromDeployment: [
    'node_modules',
    '.git',
    '.next',
    '.env*',
    'package.json',
    'package-lock.json',
    'bun.lockb',
    'tsconfig.json',
    'next.config.js',
    'installer.php' // Original installer, we'll create a new one
  ],
  compressionTargets: [
    '*.html',
    '*.css',
    '*.js',
    '*.json'
  ]
};

/**
 * Validation functions
 */
function validateBuildOutput() {
  console.log('üîç Validating build output...');
  
  if (!fs.existsSync(BUILD_DIR)) {
    throw new Error(`Build directory '${BUILD_DIR}' not found. Run 'bun run build' first.`);
  }
  
  // Check for required files
  for (const file of config.requiredFiles) {
    const filePath = path.join(BUILD_DIR, file);
    if (!fs.existsSync(filePath)) {
      throw new Error(`Required file/directory '${file}' not found in build output`);
    }
  }
  
  // Validate HTML files for Next.js export
  const indexPath = path.join(BUILD_DIR, 'index.html');
  const indexContent = fs.readFileSync(indexPath, 'utf8');
  
  if (!indexContent.includes('_next') && !indexContent.includes('next')) {
    console.warn('‚ö†Ô∏è Warning: index.html might not be a proper Next.js export');
  }
  
  console.log('‚úÖ Build output validation passed');
}

function validateSourceStructure() {
  console.log('üîç Validating source structure...');
  
  // Check for required source directories
  for (const dir of config.requiredDirs) {
    if (!fs.existsSync(dir)) {
      throw new Error(`Required source directory '${dir}' not found`);
    }
  }
  
  // Validate API structure
  const apiDir = 'api';
  const apiFiles = fs.readdirSync(apiDir);
  const phpFiles = apiFiles.filter(file => file.endsWith('.php'));
  
  if (phpFiles.length === 0) {
    throw new Error('No PHP files found in api directory');
  }
  
  console.log(`‚úÖ Found ${phpFiles.length} PHP API file(s): ${phpFiles.join(', ')}`);
  
  // Validate config structure
  const configDir = 'config';
  const configFiles = fs.readdirSync(configDir);
  console.log(`‚úÖ Found ${configFiles.length} config file(s): ${configFiles.join(', ')}`);
}

/**
 * File operations
 */
function createDeploymentStructure() {
  console.log('üìÅ Creating deployment structure...');
  
  // Clean and create deployment directory
  if (fs.existsSync(DEPLOYMENT_DIR)) {
    fs.rmSync(DEPLOYMENT_DIR, { recursive: true, force: true });
  }
  fs.mkdirSync(DEPLOYMENT_DIR, { recursive: true });
  
  console.log(`‚úÖ Created deployment directory: ${DEPLOYMENT_DIR}`);
}

function copyBuildFiles() {
  console.log('üì¶ Copying build files...');
  
  // Copy all files from build directory
  copyRecursive(BUILD_DIR, DEPLOYMENT_DIR);
  
  console.log('‚úÖ Build files copied');
}

function copySourceFiles() {
  console.log('üêò Copying PHP API and configuration files...');
  
  // Copy API directory
  const apiSource = 'api';
  const apiDest = path.join(DEPLOYMENT_DIR, 'api');
  copyRecursive(apiSource, apiDest);
  
  // Copy config directory
  const configSource = 'config';
  const configDest = path.join(DEPLOYMENT_DIR, 'config');
  copyRecursive(configSource, configDest);
  
  console.log('‚úÖ Source files copied');
}

function copyRecursive(src, dest) {
  const stat = fs.statSync(src);
  
  if (stat.isDirectory()) {
    // Create directory if it doesn't exist
    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest, { recursive: true });
    }
    
    // Copy all files in directory
    const files = fs.readdirSync(src);
    for (const file of files) {
      const srcFile = path.join(src, file);
      const destFile = path.join(dest, file);
      copyRecursive(srcFile, destFile);
    }
  } else {
    // Copy file
    fs.copyFileSync(src, dest);
  }
}

/**
 * Optimization functions
 */
function optimizeForSharedHosting() {
  console.log('‚ö° Optimizing for shared hosting...');
  
  // Create optimized .htaccess
  createHtaccess();
  
  // Create deployment manifest
  createManifest();
  
  // Create PHP configuration helper
  createPhpConfigHelper();
  
  console.log('‚úÖ Optimization complete');
}

function createHtaccess() {
  const htaccessContent = `# GlowHost Contact Form System - Shared Hosting Configuration
# Auto-generated by deployment script

# Enable URL rewriting
RewriteEngine On

# Security headers
<IfModule mod_headers.c>
  Header always set X-Content-Type-Options nosniff
  Header always set X-Frame-Options DENY
  Header always set X-XSS-Protection "1; mode=block"
  Header always set Referrer-Policy "strict-origin-when-cross-origin"
  
  # CORS headers for API
  Header always set Access-Control-Allow-Origin "*"
  Header always set Access-Control-Allow-Methods "GET, POST, OPTIONS"
  Header always set Access-Control-Allow-Headers "Content-Type, Authorization"
</IfModule>

# Cache optimization for static assets
<IfModule mod_expires.c>
  ExpiresActive On
  
  # Cache CSS and JS for 1 month
  ExpiresByType text/css "access plus 1 month"
  ExpiresByType application/javascript "access plus 1 month"
  ExpiresByType text/javascript "access plus 1 month"
  
  # Cache images for 1 month
  ExpiresByType image/png "access plus 1 month"
  ExpiresByType image/jpg "access plus 1 month"
  ExpiresByType image/jpeg "access plus 1 month"
  ExpiresByType image/gif "access plus 1 month"
  ExpiresByType image/svg+xml "access plus 1 month"
  ExpiresByType image/webp "access plus 1 month"
  
  # Cache fonts for 1 month
  ExpiresByType font/woff "access plus 1 month"
  ExpiresByType font/woff2 "access plus 1 month"
  ExpiresByType application/font-woff "access plus 1 month"
  ExpiresByType application/font-woff2 "access plus 1 month"
  
  # Cache HTML for 1 hour
  ExpiresByType text/html "access plus 1 hour"
</IfModule>

# Compression
<IfModule mod_deflate.c>
  AddOutputFilterByType DEFLATE text/plain
  AddOutputFilterByType DEFLATE text/html
  AddOutputFilterByType DEFLATE text/xml
  AddOutputFilterByType DEFLATE text/css
  AddOutputFilterByType DEFLATE application/xml
  AddOutputFilterByType DEFLATE application/xhtml+xml
  AddOutputFilterByType DEFLATE application/rss+xml
  AddOutputFilterByType DEFLATE application/javascript
  AddOutputFilterByType DEFLATE application/x-javascript
  AddOutputFilterByType DEFLATE application/json
</IfModule>

# Handle Next.js routing (fallback to index.html for client-side routing)
<IfModule mod_rewrite.c>
  # Don't rewrite files that exist
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  
  # Don't rewrite API requests
  RewriteCond %{REQUEST_URI} !^/api/
  
  # Don't rewrite asset files
  RewriteCond %{REQUEST_URI} !\\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|json|map)$
  
  # Rewrite everything else to index.html
  RewriteRule ^(.*)$ /index.html [L]
</IfModule>

# Security: Prevent access to sensitive files
<FilesMatch "\\.(env|log|bak|backup|old|tmp|temp)$">
  Order Allow,Deny
  Deny from all
</FilesMatch>

# Prevent access to config files (unless needed for your setup)
<FilesMatch "\\.(ts|tsx|js|json)$">
  <RequireAll>
    Require not env no-config-access
  </RequireAll>
</FilesMatch>

# Allow API access
<Directory "api">
  Options -Indexes
  AllowOverride None
  Require all granted
</Directory>

# Error pages
ErrorDocument 404 /404.html
ErrorDocument 500 /500.html`;

  fs.writeFileSync(path.join(DEPLOYMENT_DIR, '.htaccess'), htaccessContent);
  console.log('  ‚úÖ Created optimized .htaccess');
}

function createManifest() {
  const manifest = {
    name: "GlowHost Contact Form System",
    version: "1.0.0",
    buildTime: new Date().toISOString(),
    type: "static-export",
    deploymentStructure: {
      static: "Next.js static export files",
      api: "PHP API endpoints",
      config: "Configuration files"
    },
    requirements: {
      php: "7.4+",
      webServer: "Apache with mod_rewrite",
      features: ["PHP", "cURL", "mail()"]
    },
    files: generateFileManifest()
  };
  
  fs.writeFileSync(
    path.join(DEPLOYMENT_DIR, 'deployment-manifest.json'),
    JSON.stringify(manifest, null, 2)
  );
  console.log('  ‚úÖ Created deployment manifest');
}

function createPhpConfigHelper() {
  const phpConfigContent = `<?php
/**
 * GlowHost Contact Form System - Configuration Helper
 * Auto-generated configuration utilities
 */

// Environment detection
function detectEnvironment() {
    $indicators = [
        'shared_hosting' => [
            function_exists('cpanel_uapi'),
            isset($_SERVER['SERVER_ADMIN']) && strpos($_SERVER['SERVER_ADMIN'], 'cpanel') !== false,
            file_exists('/usr/local/cpanel'),
            defined('CPANEL')
        ],
        'glowhost' => [
            isset($_SERVER['HTTP_HOST']) && strpos($_SERVER['HTTP_HOST'], 'glowhost') !== false,
            isset($_SERVER['SERVER_NAME']) && strpos($_SERVER['SERVER_NAME'], 'glowhost') !== false
        ]
    ];
    
    $environment = 'unknown';
    foreach ($indicators as $env => $checks) {
        if (array_filter($checks)) {
            $environment = $env;
            break;
        }
    }
    
    return $environment;
}

// Check system requirements
function checkSystemRequirements() {
    $checks = [
        'php_version' => [
            'status' => version_compare(PHP_VERSION, '7.4.0', '>='),
            'message' => 'PHP 7.4+ required, found ' . PHP_VERSION
        ],
        'curl' => [
            'status' => extension_loaded('curl'),
            'message' => 'cURL extension ' . (extension_loaded('curl') ? 'available' : 'missing')
        ],
        'mail' => [
            'status' => function_exists('mail'),
            'message' => 'mail() function ' . (function_exists('mail') ? 'available' : 'unavailable')
        ],
        'json' => [
            'status' => extension_loaded('json'),
            'message' => 'JSON extension ' . (extension_loaded('json') ? 'available' : 'missing')
        ]
    ];
    
    return $checks;
}

// Configuration recommendations
function getConfigRecommendations() {
    $env = detectEnvironment();
    $recommendations = [];
    
    if ($env === 'shared_hosting') {
        $recommendations[] = "Detected shared hosting - SMTP recommended over mail()";
        $recommendations[] = "Consider using PHPMailer for better email delivery";
        $recommendations[] = "File permissions: 644 for files, 755 for directories";
    }
    
    if ($env === 'glowhost') {
        $recommendations[] = "GlowHost detected - optimizations available";
        $recommendations[] = "Consider enabling CloudFlare for better performance";
    }
    
    return $recommendations;
}

// Export functions if called directly
if (php_sapi_name() === 'cli' || (isset($_GET['action']) && $_GET['action'] === 'check')) {
    header('Content-Type: application/json');
    echo json_encode([
        'environment' => detectEnvironment(),
        'requirements' => checkSystemRequirements(),
        'recommendations' => getConfigRecommendations()
    ], JSON_PRETTY_PRINT);
}
?>`;

  fs.writeFileSync(
    path.join(DEPLOYMENT_DIR, 'config-helper.php'),
    phpConfigContent
  );
  console.log('  ‚úÖ Created PHP configuration helper');
}

function generateFileManifest() {
  const files = [];
  
  function scanDirectory(dir, basePath = '') {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const relativePath = path.join(basePath, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        scanDirectory(fullPath, relativePath);
      } else {
        const content = fs.readFileSync(fullPath);
        files.push({
          path: relativePath.replace(/\\/g, '/'), // Normalize path separators
          size: stat.size,
          modified: stat.mtime.toISOString(),
          hash: crypto.createHash('md5').update(content).digest('hex'),
          type: path.extname(item).slice(1) || 'unknown'
        });
      }
    }
  }
  
  scanDirectory(DEPLOYMENT_DIR);
  return files;
}

/**
 * Utility functions
 */
function generateChecksums() {
  console.log('üîê Generating checksums...');
  
  const checksums = {};
  const files = fs.readdirSync(DEPLOYMENT_DIR, { recursive: true });
  
  for (const file of files) {
    const filePath = path.join(DEPLOYMENT_DIR, file);
    if (fs.statSync(filePath).isFile()) {
      const content = fs.readFileSync(filePath);
      checksums[file] = crypto.createHash('sha256').update(content).digest('hex');
    }
  }
  
  fs.writeFileSync(
    path.join(DEPLOYMENT_DIR, 'checksums.json'),
    JSON.stringify(checksums, null, 2)
  );
  
  console.log(`‚úÖ Generated checksums for ${Object.keys(checksums).length} files`);
}

function createReadme() {
  const readmeContent = `# GlowHost Contact Form System - Deployment Package

## üéØ Quick Deployment

This package contains pre-built files optimized for shared hosting deployment.

### üìÅ Contents:
- **Static Files**: Pre-built Next.js application
- **API**: PHP endpoints for form processing  
- **Config**: Configuration files and helpers
- **.htaccess**: Web server optimization
- **Utilities**: Deployment helpers and validators

### üöÄ Deploy Steps:
1. Upload all files to your public_html directory
2. Ensure file permissions (644 for files, 755 for directories)  
3. Configure email settings in \`api/submit-form.php\`
4. Test the contact form functionality

### üîß Configuration:
- Run \`config-helper.php?action=check\` to validate your setup
- Check \`deployment-manifest.json\` for build details
- Review \`checksums.json\` to verify file integrity

### üìû Support:
Built for GlowHost shared hosting with optimized .htaccess and PHP configuration.

**Build Date**: ${new Date().toISOString()}
**Package Type**: Static Export + PHP API
`;

  fs.writeFileSync(path.join(DEPLOYMENT_DIR, 'README.md'), readmeContent);
  console.log('‚úÖ Created deployment README');
}

/**
 * Main execution
 */
async function main() {
  console.log('üöÄ Starting deployment build process...\n');
  
  try {
    // Validation
    validateBuildOutput();
    validateSourceStructure();
    
    // Build deployment package
    createDeploymentStructure();
    copyBuildFiles();
    copySourceFiles();
    
    // Optimization
    optimizeForSharedHosting();
    generateChecksums();
    createReadme();
    
    console.log('\n‚úÖ Deployment build completed successfully!');
    console.log(`üì¶ Deployment package ready in: ${DEPLOYMENT_DIR}`);
    
    // Summary
    const deploymentSize = getDirectorySize(DEPLOYMENT_DIR);
    const fileCount = countFiles(DEPLOYMENT_DIR);
    
    console.log(`\nüìä Package Summary:`);
    console.log(`   üìÅ Files: ${fileCount}`);
    console.log(`   üì¶ Size: ${(deploymentSize / 1024 / 1024).toFixed(2)} MB`);
    console.log(`   üéØ Ready for shared hosting deployment`);
    
  } catch (error) {
    console.error('\n‚ùå Deployment build failed:');
    console.error(error.message);
    process.exit(1);
  }
}

function getDirectorySize(dirPath) {
  let size = 0;
  const files = fs.readdirSync(dirPath, { recursive: true });
  
  for (const file of files) {
    const filePath = path.join(dirPath, file);
    if (fs.statSync(filePath).isFile()) {
      size += fs.statSync(filePath).size;
    }
  }
  
  return size;
}

function countFiles(dirPath) {
  let count = 0;
  const files = fs.readdirSync(dirPath, { recursive: true });
  
  for (const file of files) {
    const filePath = path.join(dirPath, file);
    if (fs.statSync(filePath).isFile()) {
      count++;
    }
  }
  
  return count;
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

module.exports = {
  validateBuildOutput,
  validateSourceStructure,
  createDeploymentStructure,
  optimizeForSharedHosting,
  generateChecksums
};